(* Util.m -- Daniel Reeves 
   Miscellaneous useful mathematica functions.
*)

WriteString["stderr", "[Util.m]"];

BeginPackage["Util`"];
(* All non-private symbols must be listed below... *)

shst;
FromFileName;
uniqFile;
(*some; every;*)
(* plotLabels; *)
htmlTable; labelTable; labeledMatrix; table; textTable; 
parseDataFile; parseDataString; 
empiricalCDF; blueToPink; showCDFs;
perlSplit; atoi;
allSame; cross;
withOptions; opt;
generalizedCount; nestedLoops;
randInt; randReal; 
forEach; 
removeDups;
verboseTiming; 
tmg;
doWhile;
lockFile; unlockFile;
registerProcess;
shuffle; 
getFile;
runThruString;
tupleMax; tupleMin; argMax; argMin; posMax; posMin;
reniceMyself;
lockPut; lockSave;
SYSTEMINFO; ENV;
intersperse;  (* mma 6 now has Riffle *)
mail; {to, from, subject, body, headers};
assert;
domain;
ni;
interruptedWhile; {abort};
fileAbsoluteTime; checkPoint;
StringPadRight; StringPadLeft;
nspl; dd;
seconds2str; secondsToStr; time2str; date2str;


Begin["`Private`"];  (****************************************************)

cat = StringJoin@@(ToString/@{##})&;

(* Show stuff in status line of notebook. *)
shst[stuff__] := LinkWrite[$ParentLink, 
  SetNotebookStatusLine[FrontEnd`EvaluationNotebook[], 
    StringJoin @@ (ToString /@ {stuff})]]

(* From the examples for the builtin ToFileName. *)
FromFileName[path_String] := Module[{dir, file}, 
  (dir = Most[#]; 
   file = #[[-1]])&@StringSplit[path, $PathnameSeparator | "/", All]; 
  If[Length[dir] > 0 && dir[[1]] == "", dir[[1]] = $PathnameSeparator];
  If[Length[dir] == 1, dir = dir[[1]]]; If[file == "", {dir}, {dir, file}]]
         
(* Returns a filename, concatenation of pre, number, post, where number 
   is the first available number for which there is not already a file 
   with that name. *)
uniqFile[pre_String, post_String] := Module[{i = 1},
 While[FileType[cat[pre,i,post]]=!=None, i++];
 cat[pre,i,post]]

(* every[f,l] is like And@@(f/@l) but with lazy evaluation. *)
(* now part of the MASH prescript 
every[f_, l_List] := If[Scan[If[!f[#], Return[False]]&, l]===False, False, True]
*)

(* some[f,l] is like Or@@(f/@l) but with lazy evlauation. *)
(*
some[f_, l_List] := If[Scan[If[f[#], Return[True]]&, l] === True, True, False]
*)

Util`plotLabels::usage = "\
plotLabels[l,p] takes a list of labels l and generates a list of graphics
that shows them printed at positions p.  If you have a plot in the
Mathematica front end, click on it, then hold down control while clicking
on the points you want the labels to be displayed at, then do control-c
(copy) and then pasting will give you the list of positions, p.  
You can then do Show[plot, plotLabels[l,p]] to get the labeled plot.
";
plotLabels[l_,p_] := Module[{n = Min[Length[l],Length[p]]},
  MapThread[Graphics[Text[ToString[#1], #2]]&, 
    {Take[l,n], Take[p,n]}]]

(* Returns a string that is a table in html format. *)
htmlTable[tbl_, headers_, summary_:"generated by htmlTable"] := 
Module[{htmlrow},
  htmlrow[l_] := cat["<tr>", StringJoin@@(cat["<td>",#,"</td>"]& /@ l),
                      "</tr>\n"];
  cat["<table border=\"1\" summary=\"", summary, "\">\n<tr><th>",
         intersperse["</th><th>", headers], "</th></tr>\n",
         StringJoin@@(htmlrow /@ tbl), "</table>"]]

(* Returns a matrix with rows and columns labeled. *)
labelTable[m_, rl_, cl_] := Module[{mm = m, r = PadRight[rl,Length[m],""]},
    PrependTo[mm, PadRight[cl,Length[First@m],""]];
    PrependTo[r, ""];
    Transpose[Prepend[Transpose[mm], r]]
]
labeledMatrix = labelTable;  (* deprecated name *)

(* Returns a string in TableForm. Handy for outputting tables in scripts. *)
table[t_] := StringReplace[ToString[TableForm[ni/@#&/@t]], "\n\n"->"\n"]
  (* do i need to apply InputForm to this? *)

(* Returns a string representation of a table, with optional row and 
   column labels.  Handy for outputting tables in scripts. *)
textTable[tbl_, rl_:{}, cl_:{}] :=
  Which[rl==={} && cl==={}, table[tbl],
        rl==={}, table[Prepend[tbl,cl]],
        cl==={}, table[Transpose[Prepend[Transpose[tbl], rl]]],
        True, table[labelTable[tbl,rl,cl]]]

(* Conversion options for parseDataFile and parseDataString. *)
co = {"TableSeparators"->{{"\r","\n"},{","," ","\t"}}};

(* Each line (row) contains numbers or strings that are either space or 
   comma separated. *)
parseDataFile[file_String] := Import[file, "Table", ConversionOptions->co]
parseDataString[s_String] := ImportString[s, "Table", ConversionOptions->co]

empericalCDF::usage = "Takes a list of numbers and returns a list of 
  value-probability pairs that can be ListPlotted.";
empiricalCDF[t_] :=
Flatten[{{#[[2,1]],#[[1,2]]},#[[2]]}&/@Partition[Prepend[Transpose[{#[[1]], 
Rest[FoldList[Plus,0,#[[2]]]]/Length[t]}&[Transpose[{First[#],Length[#]}&/@
Split[Sort[t]]]]],{Null,0}],2,1],1]

blueToPink[x_] := Hue[-0.83*x + 0.67]

Util`legend[labelList_, f_:blueToPink] := Module[{n = Length[labelList], p1, p2}, 
   p1 = ListDensityPlot[{Range[0,n-1], Range[0,n-1]}, Mesh->False, 
      ColorFunction->f, AspectRatio->0.1, Frame->False, 
      DisplayFunction->Identity]; 
    p2 = MapThread[Graphics[Text[ToString[InputForm[#1]],#2]]& , 
      {labelList, ({#1+0.5, 2.5}&) /@ Range[0, n-1]}]; 
    Show[p1, p2, DisplayFunction->$DisplayFunction, PlotRange->{0,3}]]

avg[l_] := Total[l]/Length[l]  (* should just use Mean[l], right? *)
(* I think these are faster than the built-in versions -- should tell mma list. *)
stddev[l_] := Module[{n = Length[l], s = Total[l], ss = Total[l^2]},
  Sqrt[(ss - n*(s/n)^2) / (n-1)]]
stderr[l_] := Module[{n = Length[l], s = Total[l], ss = Total[l^2]},
  Sqrt[(ss - n*(s/n)^2) / n]]

showCDFs[datasets_, opts___] := 
Module[{p1, p2, p3, x, n = Length[datasets], t = empiricalCDF /@ datasets}, 
  p1 = Show[MapThread[ListPlot[#1, PlotJoined->True,
                                   PlotStyle->{blueToPink[(#2-1)/Max[1,n-1]]}, 
                                   DisplayFunction->Identity]& , 
                      {t, Range[n]}], 
        PlotRange->All, Frame->True, Axes->False, 
        (* GridLines->{Automatic,Range[0,1,.1]}, *)
        DisplayFunction->Identity];
  p2 = Show[Graphics[MapThread[{blueToPink[(#2-1)/Max[1,n-1]], 
                                Dashing[{.01,.06}], 
                                Line[{{#1,0},{#1,.025}}]}&, (* .025 -> 1 *)
                               {avg/@datasets, Range[n]}]], 
         DisplayFunction->Identity];
  p3 = Show[MapThread[Plot[1/2*(1+Erf[(x-#1[[1]])/(Sqrt[2]*#1[[2]])]),
                           {x, (#1[[1]]-3*Sqrt[#1[[2]]])*0+#1[[3]], 
                               (#1[[1]]+3*Sqrt[#1[[2]]])*0+#1[[4]]}, 
                           PlotStyle->{Dashing[{.004,.01}], 
                                       blueToPink[(#2-1)/Max[1,n-1]]},
                           DisplayFunction->Identity]&,
                      {{avg[#],stddev[#],Min[#],Max[#]}& /@ datasets, 
                        Range[n]}]];
  p4 = Show[MapThread[Plot[
     (* 1/2*(1+Erf[(x-#1[[1]])/(Sqrt[2]*#1[[2]])]), *)
        1/2*(1+BetaRegularized[#1[[5]]/(#1[[5]]+((x-#1[[1]])/#1[[2]])^2),1,#1[[5]]/2,1/2]*Sign[(x-#1[[1]])/#1[[2]]]),
                           {x, (#1[[1]]-3*Sqrt[#1[[2]]])*0+#1[[3]], 
                               (#1[[1]]+3*Sqrt[#1[[2]]])*0+#1[[4]]}, 
                           PlotStyle->{Dashing[{.01,0}], 
                                       blueToPink[(#2-1)/Max[1,n-1]]},
                           DisplayFunction->Identity]&,
                    {{avg[#],stderr[#],Min[#],Max[#],Length[#]}& /@ datasets, 
                        Range[2,n+1]}]];
  Show[p1,p2 (* ,p4*), DisplayFunction->$DisplayFunction, opts]   
  (* could use DisplayTogether *)
]
(***************************************************************************
Notes on visualizing empirical distributions and compariing to Normal:
From: Bill Rowe <listuser@earthlink.net>
Newsgroups: comp.soft-sys.math.mathematica
Subject: Re: stats
Date: Fri, 28 Feb 2003 10:20:06 +0000 (UTC)

The general idea is to construct a Q-Q plot of the data.

Again using a normal distribution as an example your could do the following,

d={First[#],Length[#]}&/@Split[Sort[data]];
f=Rest[FoldList[Plus,0,Last/@d]]/(Length[data]+1);
ListPlot[MapThread[{First[#1],Quantile[NormalDistribution[0,1],#2}]&,{d,f}]];

What I've done here is compute the empirical cumulative distribution function
for your data in f and plotted this against quantiles of the unit normal
distribution. If the data is normally distributed, this should plot as a
straight line. Significant deviations would be an indication of non-normality.

Basically, the idea is to plot quantiles computed from your data against the
expected quantiles of a given distribution. If the given distribution is a good
model for the data, then the resulting plot should be a straight line.

From: drbob@bigfoot.com
start here:
http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm
The Anderson-Darling, K-S, and Chi-square goodness of fit tests give an 
objective measure, however flawed.  A plot can yield, at best, a gut 
feeling.
*****************************************************************************)



perlSplit::usage = "perlSplit[delim, list-or-string] is a handy utility for 
                    splitting like perl does.";
perlSplit[delim_String, l_List] :=
  Select[Split[l, !(#1===delim||#2===delim)&], #=!={delim}&]
perlSplit[delim_String, s_String] := StringJoin/@perlSplit[delim,Characters[s]]

atoi::usage = "Convert string to integer.";
atoi[s_String] := Which[
   SyntaxQ[s] && (NumericQ[ToExpression[s]] || ToExpression[s]==Infinity),
      ToExpression[s],
   True,
      perr["String <", s, "> cannot be interpreted as an integer.\n"];
      Exit[1]
]   


(* TODO: perhaps Union[l] == {First[l]} would be faster.
         or using Fold with a Return to break out upon non-identical element *)
allSame::usage = "allSame[l] returns whether all elements of l are identical.";
allSame[{}] = True;
allSame[{_}] := True;
allSame[{a_,b_,r___}] := a==b && allSame[{b,r}]

(* TODO: cross[l__] := Tuples[{l}] ? *)
cross::usage = "Returns the cross product of the lists given as arguments.  
               Eg, cross[{a, b}, {1, 2}] = {{a, 1}, {a, 2}, {b, 1}, {b, 2}}.
               TODO : might be better to use Outer[List, l].";
cross[l__] := Distribute[{l}, List]

opt::usage = "Used in withOptions to access Options.  For example, opt[arg] 
             in the body of a function will get the value of option arg.";
(* no definition needed as it's only a wrapper *)
             
withOptions::usage = 
  "withOptions[defaults, overrides, body] evaluates body after applying the
  replacement rules overrides and then applying defaults.";
SetAttributes[withOptions, HoldAll];
withOptions[defaults_, overrides_, body_]:=
  ReleaseHold[ Hold[body] /. 
    (opt[#1]->#2&) @@@ Join[Evaluate[overrides],Evaluate[defaults]]]

generalizedCount::usage =
  "generalizedCount[lowerBounds_List,upperBounds_List] is a further
   generalization of counting in an arbitrary base.
   generalizedCount[{3,2,4},{4,2,6}] gives
   {{3,2,4},{3,2,5},{3,2,6},{4,2,4},{4,2,5},{4,2,6}. Counting in base b is the
   following special case: generalizedCount[{0,0,0},{b,b,b}] which gives all
   3-digit numbers in base b, each expressed as a list of digits.";
generalizedCount[lowerBounds_List, upperBounds_List] := Module[
  {depth = Min[Length[lowerBounds], Length[upperBounds]], c, i}, 
  Flatten[Table @@ Prepend[Table[{c[i], lowerBounds[[i]], upperBounds[[i]]}, 
    {i, 1, depth}], Table[c[i], {i, 1, depth}]], depth - 1]]
                 
nestedLoops::usage =
  "nestedLoops[depth_Integer,lower_Function,upper_Function] is a further
  generalization of generalizedCount in which lower and upper are functions
  that take the previous list of indices and returns the lower and upper bounds
  for the next inner loop.  So to start out, the list of indices is {} and
  lower and upper take that as an argument and return the bounds for the
  outermost loop.  At some later point, the indices may be, say, {3,4,2}
  meaning that the counter for the outermost loop is at 3, the next one in is
  at 4, and the 3rd one is at 2.  lower will take that and return the
  lowerbound on the 4th nested loop in.  So generalizedCount can be implemented
  with nestedLoops as follows:
  nestedLoops[depth,lowerbounds[[Length[#]+1]]&,upperbounds[[Length[#]+1]]&].
  Or Table[IntegerDigits[i, 10, 6], {i, 0, 10^6-1}] can be implemented as
  nestedLoops[6, 0&, 9&].";
nestedLoops[depth_Integer, lower_, upper_] := Module[{c,i,j},
  Flatten[Table @@ Prepend[
    Table[{c[i], 
      lower[Table[c[j], {j, 1, i - 1}]], 
      upper[Table[c[j], {j, 1, i - 1}]]}, {i, 1, depth}], 
    Table[c[i], {i, 1, depth}]], depth - 1]]
   
randInt::usage = "randInt[a,b] returns a random integer from a thru b, " <> 
                 "inclusive.  randInt[] returns 0 or 1.";
randInt[a_:0, b_:1] := Random[Integer, {a,b}]

randReal::usage = "randReal[a,b] returns a random real between a and b.  " <> 
                  "a and b default to 0 and 1.";
randReal[a_:0, b_:1] := Random[Real, {a,b}]

(* I put this in mash.pl as "each" *)
forEach::usage = "forEach[pattern, list, body] converts pattern to body " <> 
                 "for each element of list.";
SetAttributes[forEach, HoldAll];
forEach[pattern_, list_, body_] := 
  Scan[Replace[#, pattern :> body] &, Evaluate[list]]


(* there's now the builtin DeleteDuplicates *)
removeDups::usage = "Like Union but doesn't sort.";
removeDups[l_] := Block[{i}, i[n_] := (i[n] = Sequence[]; n); i /@ l]


verboseTiming::usage = "verboseTiming[predictedTime_][expression_] is like " <>
                       "Timing[expression] but with other stuff printed.";
SetAttributes[verboseTiming, HoldRest];
verboseTiming[predictedTime_, expression_] := Module[{t},
  Print["BEGIN run for ", predictedTime, "s starting at ", 
        ToDate[AbsoluteTime[]], 
        " till ", ToDate[AbsoluteTime[] + predictedTime]];
  t = Timing[expression];
  Print["END at ", ToDate[AbsoluteTime[]]];
  t]

(* Timing but with more details. *)
SetAttributes[tmg, HoldFirst];
tmg[x_] := Module[{t, r, start, stop, w},
  start = AbsoluteTime[];
  {t, r} = Timing[x];
  stop = AbsoluteTime[];
  t = (t /. Second -> 1);
  w = stop - start; (* wall clock time *)
  pout["CPU:  ", seconds2str[Round@t], 
   " = ", ni[t,2], " s = ", ni[t/3600], " h\n",
   "WALL: ", seconds2str[Round@w], 
   " = ", ni[w,2], " s = ", ni[w/3600], " h\n"];
  r
]

doWhile::usage = "doWhile[body,test] implements a C-style do loop.";
SetAttributes[doWhile, HoldAll];
doWhile[body_, test_] := 
  While[True, Evaluate[body]; If[!Evaluate[test], Break[]]]


(* TODO: the path to lockfile could change *)
lockFile::usage = "Locks the specified file for atomic writes.";
lockFile[filename_String] := Module[{returnVal},
  returnVal = Run["lockfile " <> filename <> ".lock"];
  If[returnVal =!= 0, 
    perr["WARNING: lockfile didn't work; trying /usr/um/bin/lockfile\n"];
    returnVal = Run["/usr/um/bin/lockfile " <> filename <> ".lock"];
  ];
  If[returnVal =!= 0, 
    perr["WARNING: /usr/um/bin/lockfile didn't work; ", 
         "trying /usr/bin/lockfile\n"];
    returnVal = Run["/usr/bin/lockfile " <> filename <> ".lock"];
  ];
  If[returnVal =!= 0, 
    perr["WARNING: /usr/bin/lockfile didn't work; ", 
         "trying /usr/gnu/bin/lockfile\n"];
    returnVal = Run["/usr/gnu/bin/lockfile " <> filename <> ".lock"];
  ];
  If[returnVal =!= 0,
    perr["WARNING: lockfile *still* didn't work; giving up...\n"];
  ];

  (* perr["DIAGNOSTICS: lockfile returned ", returnVal, "\n"]; *)
  returnVal
]

unlockFile::usage = "Unlocks the specified file.";
unlockFile[filename_String] := Run["rm -f " <> filename <> ".lock"];


registerProcess::usage = 
  "registerProcess[proccesIdFile, info] appends the process id and machine 
  name and info string to the processIdFile.  My perl script signal-all.pl 
  can be run with this file as an arg to send all the processes in the file 
  a signal.  It's a good idea to call this function at the beginning of a 
  program that runs for a long time and may be invoked on many machines.";
registerProcess[processIdFile_String, info_String] := Module[{r},
  assert[StringPosition[info, "\n"] === {}];  (* no newline in info *)
  lockFile[processIdFile];
  r = OpenAppend[processIdFile];
  WriteString[r, cat[$MachineName, If[$MachineDomain =!= "", ".", ""],
    $MachineDomain, " ", $ProcessID, " ", info, "\n"]];
  Close[r];
  unlockFile[processIdFile];
]


shuffle::usage = "Takes a list and returns a random permutation of it.";
shuffle[l_List] := #2& @@@ Sort[{Random[],#}& /@ l]
  
  
getFile::usage = 
  "getFile[filename] returns the contents of the file as a string.";
getFile[f_String] := Module[{s = Import[f, "Text"]}, 
  If[s === $Failed, "[ERROR OPENING " <> f <> "]", s]
]

runThruString::usage = "Sends a string as stdin to a command and 
  returns the command's output as a string.";
runThruString[cmd_String, input_String] := Module[{in, out, tmpFile, s},
  (* tmpFile = cat["tmp-", $MachineName, "-", $ProcessID]; *)
  tmpFile = cat["tmp-", $SessionID];
  s = OpenWrite[tmpFile];   (* Could use OpenTemporary. *)
  WriteString[s, input];
  Close[s];
  (* in = "!echo \"" <> input <> "\" | " <> cmd; *)
  in = cat["!", cmd, " < ", tmpFile];
  out = Import[in, "Text"];
  DeleteFile[tmpFile];
  If[out === $Failed, "[ERROR PIPING FROM " <> in <> "]", out]
]
runThruString[cmd_String, input_] := runThruString[cmd, ToString[input]]

(*
runThru[cmd_String, input_String] := Module[{s},
   WriteString[s = OpenTemporary[], input];
   Import["!"<>cmd<>" < " <> Close[s], "Text"]
]
*)

tupleMax::usage = 
  "tupleMax[list] returns the tuple that is lexicographically maximal.";
tupleMax[l_List] := Fold[If[OrderedQ[{#1, #2}], #2, #1]&, First[l], Rest[l]]

tupleMin::usage = 
  "tupleMin[list] returns the tuple that is lexicographically minimal.";
tupleMin[l_List] := Fold[If[OrderedQ[{#1, #2}], #1, #2]&, First[l], Rest[l]]


argMax::usage = 
  "argMax[f, domain] returns the element of domain for which f of 
  that element is maximal -- breaks ties in favor of first occurrence.";
SetAttributes[argMax, HoldFirst];
(* argMax[f_, dom_List] := tupleMax[{f[#],#}& /@ dom][[2]] *)
argMax[f_, dom_List] := Fold[If[f[#1]>=f[#2], #1, #2]&, First[dom], Rest[dom]]

argMin::usage = 
  "argMin[f, domain] returns the element of domain for which f of 
  that element is minimal.";
SetAttributes[argMin, HoldFirst];
argMin[f_, dom_List] := argMax[-f[#]&, dom]

(* This version turns out to be slower. *)
(*
posMaxSlow[f_, dom_List] := 
  argMax[f[#[[1]]] &, Transpose[{dom, Range[Length[dom]]}]][[2]]
*)

(* Position of the element x in dom for which f[x] is maximal. *)
posMax[f_, dom_List] := Module[{n = Length[dom], i, x,
                                 best = f[First@dom], bestPos = 1},
  For[i = 2, i <= n, i++,
    x = f[dom[[i]]];
    If[x > best, best = x; bestPos = i]];
  bestPos]
 
(* Analogous to posMax. *)
posMin[f_, dom_List] := posMax[(-f[#])&, dom]


(* TODO: this serendipitously works if niceValue is either an int or 
   a string, but that's probably being too sloppy. *)
reniceMyself::usage = 
  "reniceMyself[niceValue] renices this process and its parent process.";
reniceMyself[niceValue_] :=
  Run[cat["renice ", niceValue, " ", $ProcessID, " ", $ParentProcessID]]


lockPut::usage = 
  "Locks a file, then does a normal put, then unlocks the file.";
lockPut[stuff__, filename_String] := (
  Get["!lockfile " <> filename <> ".lock"];  (* TODO: use lockFile... *)
  Put[stuff, filename];
  Get["!rm -f " <> filename <> ".lock"];
)

lockSave::usage =
  "Locks a file, then does a normal Save, then unlocks the file.";
SetAttributes[lockSave, HoldRest];
lockSave[filename_String, stuff_] := (
  Run["lockfile " <> filename <> ".lock"];  (* TODO: use lockfile *)
  Save[filename, stuff];
  Run["rm -f " <> filename <> ".lock"];
)


SYSTEMINFO::usage = 
  "A string with things like machine and user name and process IDs.";
SYSTEMINFO := cat[
  "$MachineName: ", $MachineName, 
  "\n$MachineDomain: ", $MachineDomain, 
  "\n$UserName: ", $UserName, 
  "\n$ProcessID: ", $ProcessID, 
  "\n$ParentProcessID: ", $ParentProcessID, 
  "\n$CommandLine: ", $CommandLine, 
  "\nARGV: ", Global`ARGV, "\n"
]


ENV::usage = 
  "A string showing all operating system environment variables.";
ENV = Read["!/usr/bin/env", Record, RecordSeparators -> {}];
Close["!/usr/bin/env"];


intersperse::usage = "Like Perl's join function.";
intersperse[_, {}] = "";
intersperse[delim_String, l_List] := Module[{s}, 
  StringJoin @@ Drop[s[#,delim]& /@ (ToString/@l) /. s->Sequence, -1]]

(* TODO: decide which is better, this or the version above *)
intersperse2::usage = "Like Perl's join function.";
intersperse2[delim_String, l:{__String}] :=
  StringJoin @@ Drop[Flatten@Transpose[{l, Table[delim, {Length[l]}]}], -1]


mail::usage = "\n
  mail[\n
    to -> {list of addresses},  \n
    from -> \"Some Name <some@email.address>\",  (* or just email adr *) \n
    subject -> \"string\", \n
    body -> \"string\", (* see SYSTEMINFO and BODY *)\n
    headers -> {list of \"Header: stuff\" strings}  (* addit'l headers *)].\n
  Use Options[mail] to see default options.";
to::usage = "Option for mail; gives list of email addresses to send to.";
from::usage = "Option for mail; see usage for mail.";
subject::usage = "Option for mail; see usage for mail.";
body::usage = "Option for mail; see usage for mail.";
headers::usage = "Option for mail; see usage for mail.";
Options[mail] := {
  to -> {"dreeves@eecs.umich.edu"},
  from -> "MY-MMA-AGENT <dreeves@umich.edu>",
  subject -> cat["OUTPUT from process ", $ProcessID, " on ", $MachineName],
  body -> cat[SYSTEMINFO, "\nEnvironment:\n\n", ENV],
  headers -> {}
};
mail[opts___] := Module[ {opt, allHeaders, stream},
  opt[x_] := x /. {opts} /. Options[mail];
  allHeaders = Join[opt[headers], {
    "Subject: " <> opt[subject],
    "From: " <> opt[from],
    "To: " <> intersperse[", ", opt[to]]}
  ];
  stream = OpenWrite["!/usr/sbin/sendmail -oi -t"];
  WriteString[stream, intersperse["\n", allHeaders], "\n\n", opt[body]];
  Close[stream];
]


(* TODO:
   Add an optional parameter for a function to call on assertion failure, 
   which could, eg, send me email. 
*)
assert::usage = 
  "assert[test_,info_String] makes sure that test evaluates to True, 
  otherwise it sends mail and calls Exit[1].  Also, prints to STDERR.  
  Info is just extra info about what we were doing or why this 
  assertion should be true.";
SetAttributes[assert, HoldFirst];
assert[test_, info_String:""] := If[test =!= True,
  With[{error = cat["FAILED ASSERTION: ", HoldForm[test]]},
    pout[error, "\n"];
    If[info != "", pout["INFO: ", info, "\n"]];
    (* mail[subject -> cat[error, " (", info, ")"]]; *)
    Exit[1]
  ]
]


domain::usage = "List of keys (as lists) for a hash.";
SetAttributes[removeHead, {HoldAll}];
removeHead[h_[args___]] := {args}
domain[s_] := removeHead @@@ First /@ DownValues[s]


ni::usage =
  "Numeric InputForm: show as a decimal number, and on one line.";
ni[x_InputForm] := x  (* do nothing if already InputForm *)
ni[x_] := Which[
  IntegerQ[x], x,
  NumericQ[x], InputForm[N[x]],
  StringQ[x], x,
  True, InputForm[x]   (* TODO: should InputForm everything, I think *)
]
ni[x_String, _] = x
ni[x_, decplaces_] := InputForm[N[Round[x*10^decplaces]/10^decplaces]]


abort::usage = 
  "A constant used as a possible parameter to interruptedWhile.";

(* TODO: what about using Break and Continue in an interruptedWhile? *)
interruptedWhile::usage = 
  "Like a While loop except for the 1st 2 args, which say: every so many 
  seconds (and once at the end regardless) pause and execute some code, 
  presumably with the purpose of announcing some partial results or the 
  status of the computation.  If the keyword abort is passed as the first
  arg instead of a number of seconds, then the interrupts happen on receiving
  an ABRT signal (alt-. in the front end).  Note that it may be a good idea 
  to include a Pause in the interruptBody so that the loop can actually be
  aborted by sending 2 aborts in a row."; 
SetAttributes[interruptedWhile, HoldRest];
interruptedWhile[abort, interruptBody_, whileTest_, whileBody_] :=
  While[whileTest, 
    CheckAbort[While[whileTest, AbortProtect[whileBody]], 
      interruptBody]]
interruptedWhile[interruptFreq_, interruptBody_, whileTest_, whileBody_] := 
  While[whileTest,
    TimeConstrained[
      While[whileTest, AbortProtect[whileBody]],
      interruptFreq];
    interruptBody;
  ]


fileAbsoluteTime::usage = 
  "Give the AbsoluteTime of the file modification date.";
fileAbsoluteTime[fileName_String] := (Date/.FileInformation[fileName])


(* TODO: see setFirstCheckPoint in the perl version (util.pl) *)
checkPoint::usage = 
  "Call this in a loop and it will return true the " <>
  "first time and false the subsequent times except every specified " <>
  "number of seconds thereafter.";
nextCheckPoint = 0;
checkPoint[seconds_] := With[{t = AbsoluteTime[]},
   If[t >= nextCheckPoint,
      nextCheckPoint = t + seconds; 
      Return[True];
    ];
    Return[False];
]


(* TODO combine these functions to one, but keep the separate names for 
   external use 
*)

StringPadRight::usage = 
  "StringPadRight[str,n,x] pads a string on the right with 
  char x (defaults to space) such that the length is n (returns original 
  string if longer than n).  If the first arg is not a string, does 
  ToString on it.";
StringPadRight[str_String, n_Integer, x_String:" "] := 
  If[StringLength[str] >= n, str,
    StringJoin[PadRight[Characters[str], n, x]]]
StringPadRight[stuff_, n_Integer, x_String:" "] := 
  StringPadRight[ToString[stuff], n, x]

StringPadLeft::usage = 
  "StringPadLeft[str,n,x] pads a string on the left with 
  char x (defaults to space) such that the length is n (returns original 
  string if longer than n).  If the first arg is not a string, does 
  ToString on it.";
StringPadLeft[str_String, n_Integer, x_String:" "] := 
  If[StringLength[str] >= n, str,
    StringJoin[PadLeft[Characters[str], n, x]]]
StringPadLeft[stuff_, n_Integer, x_String:" "] := 
  StringPadLeft[ToString[stuff], n, x]

nspl::usage = "nspl is number-string-pad-left.";
nspl[num_, n_] := StringPadLeft[num,n,"0"]

dd::usage = 
  "dd is double-digit, for taking a number from 0-99 and returning a 
  2-character string like \"03\" or \"42\".";
dd[num_?(#<100&)] := nspl[num, 2]

(* Simpler version: *)
(* double-digit: turns a number 0-99 to a 2-char string like "03" or "42". *)
(* dd[n_] := cat[If[0<=n<10, "0", "", ""], n] *)


daysInYear = 365.242198781;  (* lightyear / c *)
weeksInYear = daysInYear / 7;
daysInMonth = daysInYear / 12;
weeksInMonth = daysInMonth / 7; 
sS = 1;
mS = 60*sS;
hS = 60*mS;
dS = 24*hS;
wS = 7*dS;
oS = daysInMonth*dS;
yS = daysInYear*dS;

(* returns an "s" if n!=1 and "" otherwise *)
maybeS[n_] := If[n===1,"","s"]

seconds2str::usage = 
  "Convert a number of seconds to years,months,weeks,days,hrs,mins,secs.";
seconds2str[secs_] := Module[
  {y, yQ= False, o, oQ= False, w, wQ= False, 
   d, dQ= False, h, hQ= False, m, mQ= False, s= secs},

  y = Floor[s / yS];
  If[y>0, yQ = oQ = wQ = dQ = hQ = mQ = True];
  s -= y * yS;

  o = Floor[s / oS];
  If[o>0, oQ = wQ = dQ = hQ = mQ = True];
  s -= o * oS;

  w = Floor[s / wS];
  If[w>0, wQ = dQ = hQ = mQ = True];
  s -= w * wS;

  d = Floor[s / dS];
  If[d>0, dQ = hQ = mQ = True];
  s -= d * dS;

  h = Floor[s / hS];
  If[h>0, hQ = mQ = True];
  s -= h * hS;

  m = Floor[s / mS];
  If[m>0, mQ = True];
  s -= m * mS;
    
  Return[cat[
    If[yQ, cat[y," year",maybeS[y]," "], ""],
    If[oQ, cat[o," month",maybeS[o]," "], ""],
    If[wQ, cat[w," week",maybeS[w]," "], ""],
    If[dQ, cat[d," day",maybeS[d]," "], ""],
    If[hQ, cat[dd[h],":"], ""],
    If[mQ, cat[dd[m],":",dd[Round[s]],"s"], cat[ni[s],"s"]]]]
]
seconds2str[secs_/;secs<0] := cat["-", seconds2str[-secs]]


(* TODO: seconds2str is a better version of this now. *)
secondsToStr::usage = 
  "Convert a number of seconds to days,hrs,mins,secs.";
secondsToStr[0, _] := ""
secondsToStr[seconds_, {label_}] := dd[seconds] <> label
secondsToStr[seconds_, {rest__, {unit_, label_}}] := 
  secondsToStr[Quotient[seconds - Mod[seconds, unit], unit], {rest}] <> 
    ToString[Mod[seconds, unit]] <> label
secondsToStr[seconds_] := 
  secondsToStr[seconds, {"days ", {24, ":"}, {60, ":"}, {60, "s"}}]
secondsToStr[0] := "0s"


time2str::usage = 
  "Convert an absolute number of seconds (add absolute time of 
  1970-1-1 00:00:00 for Unix (timezone issues?)) to a date/time string.";
time2str[t_:AbsoluteTime[], unix_:False] := Module[ {secs, y,m,d,h,min,s},
  secs = If[unix, t + FromDate[{1970,1,1,0,0,0}], t];
  {y,m,d,h,min,s} = ToDate[secs];
  cat[y,"-",dd[m],"-",dd[d],"_",
         dd[h],":",dd[min],":",dd[Round[s]]]
]

date2str::usage = "like time2str but just for dates";
date2str[t_:AbsoluteTime[], unix_:False] := Module[ {secs, y,m,d,h,min,s},
  secs = If[unix, t + FromDate[{1970,1,1,0,0,0}], t];
  {y,m,d,h,min,s} = ToDate[secs];
  cat[y,"-",dd[m],"-",dd[d]]
]

End[];   (* Private context *)
EndPackage[];
